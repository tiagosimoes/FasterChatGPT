<!DOCTYPE html>
<html>

<head>
  <title>Never Stop Learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <meta name="apple-mobile-web-app-status-bar-style" content="var(--primary-color)">
  <link rel="manifest" href="/manifest.json">
</head>

<body style="background-color: var(--background-color);">
  <div onclick="document.location.reload()"
    style="background-color: var(--primary-color); color:#ffffffee; width: 100%;top:0;padding:20px;z-index: 1; text-align: center;">
    Never Stop Learning</div>
  <button type="button" id="resetButton" onclick="document.location.reload()"
    style="width:22px;height: 42px;right: 10px;top: 110px;border-radius: 10px;padding:0;color: var(--primary-color);background-color:transparent; position: absolute; margin: 5px;opacity: 0; transition: all .3s;border: 0;">&#8635;</button>
  <div id="chatHistory" style="margin: auto;margin-bottom: 90px;">
    <div class="thinking">
      <p>...</p>
    </div>
  </div>
  <form id="chatForm"
    style="background-color: var(--background-color);position: fixed;display: block;width: 100%;bottom: 0;padding: 10px;"">
    <input id="userInput" type="text" placeholder="...or anything else (related or not)"
    style="width: calc(100% - 50px);margin: auto;box-sizing: border-box;padding: 10px;border: 1px solid #ccc;border-radius: 10px;height:42px">
    </input>
    <button type="submit" id="sendButton"
      style="width:42px;height: 42px;border-radius: 10px;padding:0;background-color: var(--primary-color);color:#ffffffee;border: 0;">⤒</button>
  </form>
  <style>
    :root {
      --primary-color: hsl(180, 66%, 21%);
      --secondary-color: hsl(180, 70%, 20%);
      --visited-color: hsl(180, 7%, 41%);
      --background-color: hsl(180, 66%, 98%);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: large;
    }

    * {
      box-sizing: border-box;
    }

    p {
      margin-block-end: 0;
      margin-block-start: 0;
    }

    .user,
    .assistant,
    .thinking,
    .suggestion {
      border-radius: 10px;
      padding: 10px;
      margin: 10px auto;
      width: fit-content;
      max-width: 90%;
      max-width: 80%;
      animation: grow .2s forwards;
      margin-bottom: 0;
    }

    .user {
      background-color: var(--primary-color);
      color: #ffffffee;
      margin-left: 20px;
      transform-origin: top left;
      border-bottom-left-radius: 0px;
    }

    .assistant,
    .thinking,
    .suggestion {
      background-color: rgb(230, 230, 230);
      color: #000000dd;
      margin-right: 20px;
      transform-origin: top right;
      border-bottom-right-radius: 0px;
    }

    .suggestion {
      cursor: pointer;
      color: var(--secondary-color);
      font-size: 16px;
      opacity: .7;
      transition: all .2s;
      margin: 10px auto;
      border-bottom-right-radius: 10px;
      margin-bottom: 0;
      background-color: rgb(240, 240, 240);
    }

    .suggestion.hidden {
      margin-top: 0;
      margin-bottom: 0;
      font-size: 0;
      padding: 0;
    }

    .suggestion.visited {
      color: var(--visited-color);
    }

    .thinking>p {
      animation: grow .5s infinite alternate;
    }

    @keyframes grow {
      from {
        transform: scale3d(0, 0, 1);
        opacity: 0;
      }

      to {
        transform: scale3d(1, 1, 1);
      }
    }
  </style>
  <script>
    const getById = id => document.getElementById(id);
    const userInputElem = getById('userInput');
    const sendButtonElem = getById('sendButton');
    const chatFormElem = getById('chatForm');
    const getDataFromDB = async key => await operateDB(key);
    const setDataInDB = async (key, parent, message) => await operateDB(key, parent, message);
    const updateInputButtonText = () => sendButtonElem.innerText = (userInputElem.value === "") ? '⤒' : '→';

    const initialPrompt = "Give me a list of 7 random different and interesting topics I could explore. Be very succinct. Just output the list.";

    var openai_key = location.hash.slice(1) || localStorage.getItem('openai_key');
    if (!openai_key) {
      document.addEventListener("DOMContentLoaded", () => appendMessageToHistory("assistant", "Please provide a valid OpenAI API key"));
      chatFormElem.addEventListener('submit', function (event) {
        event.preventDefault();
        localStorage.setItem('openai_key', userInputElem.value);
        setTimeout(() => document.location.reload(), 1000);
      });
    } else {
      getChatCompletion([{ "role": "user", "content": initialPrompt }], temperature = 1.5)
        .then(message => {
          message = "What do you want to explore? WHAT NEXT?" + message;
          if (document.readyState === 'loading')
            document.addEventListener("DOMContentLoaded", () => appendMessageToHistory("assistant", message));
          else
            appendMessageToHistory("assistant", message);
          getById('resetButton').style.opacity = 1;
        });
      chatFormElem.addEventListener('submit', function (event) {
        event.preventDefault();
        const userInput = userInputElem.value;
        if (userInput === '') {
          window.scrollTo({ top: 0, behavior: 'smooth' });
          return;
        }
        userSendMessage(userInput);
        userInputElem.value = '';
        updateInputButtonText();
      });
    }

    userInputElem.addEventListener('input', updateInputButtonText);

    const instructions = `
You are a direct, clear and fast GPT designed to offer very concise (non creative) answers with one or two sentences and then 3 suggestions for the follow up conversation. 
You should always make educated guesses. 
At the end of any response, write "WHAT NEXT?" and present 3 likely follow-up user prompts.
Clarifications, if necessary, are included in the 3 suggestions.
`;
    let chatActiveHistory = [{ "role": "system", "content": instructions }];

    function appendMessageToHistory(role, message) {
      const chatHistoryElement = getById('chatHistory');
      chatActiveHistory.push({ role, content: message });
      if (role === "assistant") {
        chatHistoryElement.lastElementChild?.remove(); // remove the thinking message
        [message, rawSuggestions] = message.split("WHAT NEXT?");
        // Regular expression to match the leading numbers and period
        const numberAndDot = /^\d+\.\s+/;
        const suggestions = !rawSuggestions ? [] : rawSuggestions.split("\n").map(s => s.replace(numberAndDot, '').trim()).filter(s => s != "");
        message = message.trim();
        apendBubble(role, message);
        suggestions.forEach(suggestion => {
          apendBubble("suggestion", suggestion);
          possibleNewChatHistory = [...chatActiveHistory].concat([{ "role": "user", "content": suggestion }]);
          getChatCompletion(possibleNewChatHistory);
        });
      } else { // user
        apendBubble(role, message);
        apendBubble("thinking", "...");
      }

      function apendBubble(role, message) {
        const newMessageElement = document.createElement('div');
        newMessageElement.classList.add(role);
        newMessageElement.innerHTML = marked.parse(message, { "breaks": true }).trim();
        if (role === "suggestion")
          newMessageElement.addEventListener('click', () => {
            previousSibling = newMessageElement.previousSibling;
            while (previousSibling && previousSibling.classList.contains("suggestion")) {
              convertHiddenSuggestionToVisited(previousSibling);
              previousSibling = previousSibling.previousSibling
            }
            nextSibling = newMessageElement.nextSibling;
            while (nextSibling && nextSibling?.classList.contains("suggestion")) {
              convertHiddenSuggestionToVisited(nextSibling);
              nextSibling = nextSibling.nextSibling;
            }
            removeAllMessagesFromThisToBottom(nextSibling);
            userSendMessage(message, true);
            newMessageElement.classList.add("hidden");
          });
        chatHistoryElement.appendChild(newMessageElement);
        if (role !== "suggestion")
          newMessageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function convertHiddenSuggestionToVisited(element) {
      if (element.classList.contains("hidden")) {
        element.classList.remove("hidden");
        element.classList.add("visited");
      }
    }

    function removeAllMessagesFromThisToBottom(element) {
      let userMessagegDeleted = 0;
      while (nextSibling) {
        storeNextSibling = nextSibling.nextSibling;
        if (nextSibling.classList.contains("user"))
          userMessagegDeleted++;
        nextSibling.remove();
        nextSibling = storeNextSibling;
      }
      chatActiveHistory = chatActiveHistory.toSpliced(chatActiveHistory.length - userMessagegDeleted * 2);
    }

    async function userSendMessage(userInput, fromSuggestion = false) {
      appendMessageToHistory("user", userInput);
      try {
        newMessage = await getChatCompletion(chatActiveHistory, null, fromSuggestion);
        appendMessageToHistory("assistant", newMessage);
      } catch (error) {
        appendMessageToHistory("assistant", error.message);
      }
    }

    async function getChatCompletion(previousMessages, temperature = 1, fromSuggestion = false) {
      const onlyUserMessages = previousMessages.filter(message => message.role === "user").map(message => message.content).join("\n");
      let record = await getDataFromDB(onlyUserMessages);
      while (!record && fromSuggestion)
        record = await getDataFromDB(onlyUserMessages);
      if (record)
        return record.message;
      if (previousMessages.length > 7) {
        // send just the instructions + the last 6 messages (to save tokens)
        previousMessages = previousMessages.toSpliced(1, previousMessages.length - 7);
      }
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ` + openai_key },
        body: JSON.stringify({ model: 'gpt-3.5-turbo', messages: previousMessages, temperature: temperature })
      });
      if (response.status === 401) {
        localStorage.removeItem('openai_key');
        document.location.reload();
      }
      if (!response.ok) return "Error: " + response.text;
      const { choices } = await response.json();
      let message = choices[0].message.content;
      if (onlyUserMessages !== initialPrompt)
        setDataInDB(onlyUserMessages, message);
      return message;
    }

    async function operateDB(key, message = null) {
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open("ChatDB", 3);
        request.onupgradeneeded = e => e.target.result.createObjectStore("messages", { keyPath: "id" });
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
      const tx = db.transaction("messages", "readwrite");
      const store = tx.objectStore("messages");
      return new Promise((resolve, reject) => {
        const request = message ? store.put({ id: key, message: message }) : store.get(key);
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
    }

  </script>
</body>

</html>