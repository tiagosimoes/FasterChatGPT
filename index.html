<!DOCTYPE html>
<html>

<head>
  <title>Never Stop Learning</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <meta name="apple-mobile-web-app-status-bar-style" content="var(--primary-color)">
  <link rel="manifest" href="/manifest.json">
</head>

<body style="background-color: var(--background-color);">
  <div onclick="document.location.reload()"
    style="background-color: var(--primary-color); color:#ffffffee; width: 100%;top:0;padding:20px;z-index: 1; text-align: center;">
    Never Stop Learning</div>
  <button type="button" id="resetButton" onclick="document.location.reload()"
    style="color:#ffffffee;width:22px;height: 42px;right: 10px;top: 5px;border-radius: 10px;padding:0;background-color:transparent; position: absolute; margin: 5px;opacity: 0; transition: all .3s;border: 0;">&#8635;</button>
  <div id="chatHistory" style="margin: auto;margin-bottom: 90px;">
    <div class="thinking">
      <p>...</p>
    </div>
  </div>
  <form id="chatForm"
    style="background-color: var(--background-color);position: fixed;display: block;width: 100%;bottom: 0;padding: 10px;"">
    <input id="userInput" type="text" placeholder="...or anything else (related or not)"
    style="width: calc(100% - 50px);margin: auto;box-sizing: border-box;padding: 10px;border: 1px solid #ccc;border-radius: 10px;height:42px">
    </input>
    <button type="submit" id="sendButton" disabled="true">⤒</button>
  </form>
  <style>
    :root {
      --primary-color: hsl(180, 66%, 21%);
      --secondary-color: hsl(180, 70%, 20%);
      --visited-color: hsl(180, 7%, 41%);
      --background-color: hsl(180, 66%, 98%);
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: large;
    }

    #sendButton {
      width: 42px;
      height: 42px;
      border-radius: 10px;
      padding: 0;
      background-color: var(--primary-color);
      color: #ffffffee;
      border: 0;
    }

    #sendButton:disabled {
      color: #999;
      background-color: rgb(240, 240, 240);
    }

    * {
      box-sizing: border-box;
    }

    p {
      margin-block-end: 0;
      margin-block-start: 0;
    }

    .user,
    .assistant,
    .thinking,
    .suggestion {
      border-radius: 15px;
      padding: 10px;
      margin: 10px auto;
      width: fit-content;
      max-width: 90%;
      max-width: 80%;
      animation: grow .2s forwards;
      margin-bottom: 0;
    }

    .user {
      background-color: var(--primary-color);
      color: #ffffffee;
      margin-left: 20px;
      transform-origin: top left;
      border-bottom-left-radius: 0px;
    }

    .assistant,
    .thinking,
    .suggestion {
      background-color: rgb(230, 230, 230);
      color: #000000dd;
      margin-right: 20px;
      transform-origin: top right;
      border-bottom-right-radius: 0px;
    }

    .suggestion {
      cursor: pointer;
      color: var(--secondary-color);
      font-size: 16px;
      opacity: .7;
      transition: all .2s;
      margin: 10px auto;
      border-bottom-right-radius: 10px;
      margin-bottom: 0;
      background-color: rgb(240, 240, 240);
      animation: appear 2s forward;
    }

    .suggestion.hidden {
      margin-top: 0;
      margin-bottom: 0;
      font-size: 0;
      padding: 0;
    }

    .suggestion.visited {
      color: var(--visited-color);
    }

    .thinking>p {
      animation: grow .5s infinite alternate;
    }

    @keyframes appear {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }
  </style>
  <script>
    const historySeparator = "\n";
    const getById = id => document.getElementById(id);
    const userInputElem = getById('userInput');
    const sendButtonElem = getById('sendButton');
    const chatFormElem = getById('chatForm');
    const chatHistoryElem = getById('chatHistory');

    const getDataFromDB = async key => await putOrGetInIndexDB(key);
    const setDataInDB = async object => await putOrGetInIndexDB(object);
    const updateInputButtonDisabled = () => sendButtonElem.disabled = (window.scrollY <= 60 && userInputElem.value === "");
    userInputElem.addEventListener('input', updateInputButtonText);
    chatFormElem.addEventListener('submit', onSubmit);
    window.addEventListener('scroll', updateInputButtonDisabled);

    var openai_key = location.hash.slice(1) || localStorage.getItem('openai_key');
    if (!openai_key) {
      document.addEventListener("DOMContentLoaded", () => appendMessageToHistory("assistant", "Please enter a valid OpenAI API key"));
      userInputElem.placeholder = "OpenAI API key";
    } else {
      const initialPrompt = "Give me a list of 7 random different and interesting topics I could explore. Be very succinct. Just output the list.";
      getChatCompletionFromAI([{ "role": "user", "content": initialPrompt }], temperature = 1.5)
        .then(message => {
          message = "What do you want to explore? WHAT NEXT?" + message;
          if (document.readyState === 'loading')
            document.addEventListener("DOMContentLoaded", () => appendMessageToHistory("assistant", message));
          else
            appendMessageToHistory("assistant", message);
          getById('resetButton').style.opacity = 1;
        });
    }

    function onSubmit(event) {
      event.preventDefault();
      const userInput = userInputElem.value;
      if (userInput === '') {
        window.scrollTo({ top: 0, behavior: 'smooth' });
        return;
      }
      if (!openai_key) {
        localStorage.setItem('openai_key', userInput);
        setTimeout(() => document.location.reload(), 1000);
        return;
      }
      userSendMessage(userInput);
      userInputElem.value = '';
      updateInputButtonText();
    }

    function updateInputButtonText() {
      sendButtonElem.innerText = userInputElem.value === '' ? '⤒' : '→';
      updateInputButtonDisabled();
    }

    const instructions = `
You are a direct, clear and fast GPT designed to offer very concise (non creative) answers with one or two sentences and then 3 suggestions for the follow up conversation. 
You should always make educated guesses. 
At the end of any response, write "WHAT NEXT?" and present 3 likely follow-up user prompts.
Clarifications, if necessary, are included in the 3 suggestions.
`;
    let chatActiveHistory = [{ "role": "system", "content": instructions }];

    function appendMessageToHistory(role, message) {
      chatActiveHistory.push({ role, content: message });
      if (role === "assistant") {
        chatHistoryElem.lastElementChild?.remove(); // remove the thinking message
        [message, rawSuggestions] = message.split("WHAT NEXT?");
        // Regular expression to match the leading numbers and period
        const numberAndDot = /^\d+\.\s+/;
        const suggestions = !rawSuggestions ? [] : rawSuggestions.split("\n").map(s => s.replace(numberAndDot, '').trim()).filter(s => s != "");
        message = message.trim();
        appendBubble(role, message);
        suggestions.forEach(suggestion => {
          appendBubble("suggestion", suggestion);
          possibleNewChatHistory = [...chatActiveHistory].concat([{ "role": "user", "content": suggestion }]);
          getChatCompletionFromCacheOrAI(possibleNewChatHistory);
        });
      } else { // user
        appendBubble(role, message);
        appendBubble("thinking", "...");
      }

      function appendBubble(role, message) {
        const newMessageElement = document.createElement('div');
        newMessageElement.classList.add(role);
        newMessageElement.innerHTML = marked.parse(message, { "breaks": true }).trim();
        if (role === "suggestion")
          newMessageElement.addEventListener('click', () => {
            previousSibling = newMessageElement.previousSibling;
            while (previousSibling && previousSibling.classList.contains("suggestion")) {
              convertHiddenSuggestionToVisited(previousSibling);
              previousSibling = previousSibling.previousSibling
            }
            nextSibling = newMessageElement.nextSibling;
            while (nextSibling && nextSibling?.classList.contains("suggestion")) {
              convertHiddenSuggestionToVisited(nextSibling);
              nextSibling = nextSibling.nextSibling;
            }
            removeAllMessagesFromThisToBottom(nextSibling);
            userSendMessage(message, true);
            newMessageElement.classList.add("hidden");
          });
        chatHistoryElem.appendChild(newMessageElement);
        if (role !== "suggestion")
          newMessageElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }

    function convertHiddenSuggestionToVisited(element) {
      if (element.classList.contains("hidden")) {
        element.classList.remove("hidden");
        element.classList.add("visited");
      }
    }

    function removeAllMessagesFromThisToBottom(element) {
      let userMessagegDeleted = 0;
      while (nextSibling) {
        storeNextSibling = nextSibling.nextSibling;
        if (nextSibling.classList.contains("user"))
          userMessagegDeleted++;
        nextSibling.remove();
        nextSibling = storeNextSibling;
      }
      chatActiveHistory = chatActiveHistory.toSpliced(chatActiveHistory.length - userMessagegDeleted * 2);
    }

    async function userSendMessage(userInput, waitForCache = false) {
      appendMessageToHistory("user", userInput);
      try {
        newMessage = await getChatCompletionFromCacheOrAI(chatActiveHistory, waitForCache);
        appendMessageToHistory("assistant", newMessage);
      } catch (error) {
        appendMessageToHistory("assistant", error.message);
      }
    }

    async function getChatCompletionFromCacheOrAI(previousMessages, waitForCache = false) {
      const allPreviousUserMessages = previousMessages.filter(m => m.role === "user").map(m => m.content).join(historySeparator);
      let record = await getDataFromDB(allPreviousUserMessages);
      while (!record && waitForCache)
        record = await getDataFromDB(allPreviousUserMessages);
      if (record) {
        //children = await getDirectChildObjectsWithPrefix(allPreviousUserMessages);
        //console.log(children);
        return record.message;
      }
      const message = await getChatCompletionFromAI(previousMessages, 1);
      await setDataInDB({ key: allPreviousUserMessages, message: message });
      return message;
    }

    async function getChatCompletionFromAI(previousMessages, temperature) {
      if (previousMessages.length > 7) {
        // send just the instructions + the last 6 messages (to save tokens)
        previousMessages = previousMessages.toSpliced(1, previousMessages.length - 7);
      }
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ` + openai_key },
        body: JSON.stringify({ model: 'gpt-3.5-turbo', messages: previousMessages, temperature: temperature })
      });
      if (response.status === 401) {
        localStorage.removeItem('openai_key');
        document.location.reload();
      }
      if (!response.ok) return "Error: " + response.text;
      const { choices } = await response.json();
      return choices[0].message.content;
    }

    async function getIndexDBStore() {
      const tableName = "messagesV1";
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open("ChatDB", 4);
        request.onupgradeneeded = e => e.target.result.createObjectStore("messagesV1", { keyPath: "key" });
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
      const tx = db.transaction(tableName, "readwrite");
      const store = tx.objectStore(tableName);
      return store;
    }

    async function putOrGetInIndexDB(keyOrObject) {
      const store = await getIndexDBStore();
      return new Promise((resolve, reject) => {
        const request = typeof keyOrObject === "object" ? store.put(keyOrObject) : store.get(keyOrObject);
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
    }

    async function getDirectChildObjectsWithPrefix(prefix) {
      const store = await getIndexDBStore()
      const keyRange = IDBKeyRange.bound(prefix, prefix + '\uffff');
      const request = store.openCursor(keyRange);
      const results = [];
      const escapeRegex = (string) => string.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
      const regex = new RegExp(`^${escapeRegex(prefix + historySeparator)}`);
      return new Promise((resolve, reject) => {
        request.onsuccess = e => {
          const cursor = e.target.result;
          if (cursor) {
            if (regex.test(cursor.key))
              results.push(cursor.value);
            cursor.continue();
          } else
            resolve(results);
        };
        request.onerror = e => reject('Error in fetching data: ' + e.target.errorCode);
      });
    }

  </script>
</body>

</html>