<!DOCTYPE html>
<html>

<head>
  <title>Faster ChatGPT</title>
  <meta name="description" content="Type less (or nothing at all) and get faster results.">
  <meta property="og:title" content="Faster ChatGPT" />
  <meta property="og:description" content="Type less (or nothing at all) and get faster results." />

  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <meta name="apple-mobile-web-app-status-bar-style" content="var(--primary-color)">
  <link rel="manifest" href="manifest.json">
</head>

<body style="background-color: var(--background-color);">
  <div
    style="background: var(--header-gradient); color:#ffffffee; width: 100%;top:0;padding:20px;z-index: 1; text-align: center;">
    Faster ChatGPT</div>
  <button type="button" id="archiveButton"
    style="color:#ffffffee;width:22px;height: 42px;left: 10px;top: 5px;border-radius: 10px;padding:0;background-color:transparent; position: absolute; margin: 5px;opacity: 0; transition: all .3s;border: 0;">&#8634;</button>
  <button type="button" id="refreshButton"
    style="color:#ffffffee;width:22px;height: 42px;right: 10px;top: 5px;border-radius: 10px;padding:0;background-color:transparent; position: absolute; margin: 5px;opacity: 0; transition: all .3s;border: 0;">&#8635;</button>
  <div id="chatHistory" style="margin: auto;margin-bottom: 90px;"></div>
  <form id="chatForm"
    style="background-color: var(--background-color);position: fixed;display: block;width: 100%;bottom: 0;padding: 10px;"">
    <input id="userInput" type="text" autofocus="true" autocomplete="off" autocapitalize="off"
    style="width: calc(100% - 50px);margin: auto;box-sizing: border-box;padding: 10px;border:1px solid var(--primary-color);border-radius: 10px;height:42px">
    </input>
    <button type="submit" id="sendButton" disabled="true">⤒</button>
  </form>
  <style>
    :root {
      --primary-color: hsl(180, 66%, 21%);
      --secondary-color: hsl(180, 70%, 20%);
      --assistant-background: hsl(180, 19%, 93%);
      --assistant-forground: hsl(180, 11%, 25%);
      --suggestion-background: hsl(180, 19%, 97%);
      --visited-color: hsl(180, 7%, 25%);
      --background-color: hsl(180, 66%, 98%);
      --header-gradient: linear-gradient(0, hsl(180, 36%, 18%), hsl(180, 66%, 21%));
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: large;
    }

    #sendButton {
      width: 42px;
      height: 42px;
      border-radius: 10px;
      padding: 0;
      background-color: var(--primary-color);
      color: #ffffffee;
      border: 0;
    }

    #sendButton:disabled {
      color: #999;
      background-color: rgb(240, 240, 240);
    }

    input:focus-visible {
      outline: 1px solid var(--primary-color);
    }

    * {
      box-sizing: border-box;
    }

    p {
      margin-block-end: 0;
      margin-block-start: 0;
    }

    .user,
    .assistant,
    .thinking,
    .suggestion {
      border-radius: 15px;
      padding: 10px;
      margin: 10px auto;
      width: fit-content;
      max-width: 90%;
      max-width: 80%;
      animation: grow .2s forwards;
      margin-bottom: 0;
      word-wrap: break-word;
    }

    .user {
      background-color: var(--primary-color);
      color: #ffffffee;
      margin-left: 20px;
      transform-origin: top left;
      border-bottom-left-radius: 0px;
    }

    .assistant,
    .thinking,
    .suggestion {
      background-color: var(--suggestion-background);
      color: #000000dd;
      margin-right: 20px;
      transform-origin: top right;
      border-bottom-right-radius: 0px;
    }

    .thinking,
    .assistant {
      background-color: var(--assistant-background);
      color: var(--assistant-forgroundr);
    }

    .suggestion {
      cursor: pointer;
      color: var(--secondary-color);
      font-size: 16px;
      opacity: .7;
      transition: all .2s;
      margin: 10px auto;
      border-bottom-right-radius: 10px;
      margin-bottom: 0;
      background-color: rgb(240, 240, 240);
      animation: appear 2s forward;
      user-select: none;
      -webkit-user-select: none;
    }

    .suggestion.hidden {
      margin-top: 0;
      margin-bottom: 0;
      font-size: 0;
      padding: 0;
    }

    .suggestion.visited {
      color: var(--visited-color);
    }

    .thinking>p {
      animation: grow .5s infinite alternate;
    }

    @keyframes grow {
      from {
        transform: scale(0);
      }

      to {
        transform: scale(1);
      }
    }
  </style>
  <script>
    const instructions = `
You are a direct, clear and fast GPT designed to offer very concise (non creative) answers with one or two sentences and then 3 suggestions for the follow up conversation. 
You should always make educated guesses. 
At the end of any response, write "WHAT NEXT?" and present 3 likely follow-up user prompts.
Clarifications, if necessary, are included in the 3 suggestions.
`;
    const firstInitialSuggestions = `
- Artificial intelligence and its ethical implications.
- The future of sustainable energy sources.
- The impact of social media on society.
- The potential for life beyond Earth.
- The psychology behind decision-making.
- The role of genetics in human health and behavior.
- The influence of technology on human relationships.
`;
    if (!localStorage.getItem("nextInitialSuggestions"))
      localStorage.setItem("nextInitialSuggestions", firstInitialSuggestions); // to make the very first initial load faster
    let chatActiveHistory = [];
    const historySeparator = "\n";
    const getById = id => document.getElementById(id);
    const userInputElem = getById("userInput");
    const sendButtonElem = getById("sendButton");
    const chatFormElem = getById("chatForm");
    const chatHistoryElem = getById("chatHistory");
    const archiveButtonElem = getById("archiveButton");
    const refreshButtonElem = getById("refreshButton");


    const getDataFromDB = key => putOrGetInIndexDB(key);
    const setDataInDB = object => putOrGetInIndexDB(object);
    const updateInputButtonDisabled = () => sendButtonElem.disabled = ((isScrollToTopState() && window.scrollY <= 60) || (!isScrollToTopState() && userInputElem.value === ""));
    const isScrollToTopState = () => sendButtonElem.innerText === "⤒";
    const scrollToTop = () => window.scrollTo({ top: 0, behavior: "smooth" });


    userInputElem.addEventListener("input", updateInputButtonText);
    userInputElem.addEventListener("focus", updateInputButtonText);
    userInputElem.addEventListener("blur", updateInputButtonText);
    archiveButtonElem.addEventListener("click", showArchive);
    refreshButtonElem.addEventListener("click", getInitialSuggestions);
    chatHistoryElem.addEventListener("click", () => userInputElem.blur() /*  hide the keyboard on mobile */);
    chatFormElem.addEventListener("submit", onSubmit);
    window.addEventListener("scroll", updateInputButtonDisabled);

    const openai_key = location.hash.slice(1) || localStorage.getItem("openai_key");

    if (location.hash) {
      history.pushState(null, "", location.href.split('#')[0]);  // Clear the hash in the UR
      localStorage.setItem("openai_key", openai_key);
    }

    if (!openai_key) {
      document.addEventListener("DOMContentLoaded", () => appendAssistantMessage("Type less (or nothing at all) and get faster results.  <br><br>Please enter your [OpenAI API key](https://platform.openai.com/account/api-keys)"));
      userInputElem.placeholder = "OpenAI API key";
      chatFormElem.removeEventListener("submit", onSubmit);
      chatFormElem.addEventListener("submit", onOpenAIKeySubmit);
    } else {
      // get the "q" query parameter
      const urlParams = new URLSearchParams(window.location.search);
      const q = urlParams.get('q');
      if (q != null) {
        chatActiveHistory = [{ role: "system", content: instructions }];
        refreshButtonElem.style.opacity = 1;
        if (q != "") {
          document.addEventListener("DOMContentLoaded", () => {
            appendSuggestionBubbleAndGetFromAI(q, true);
            userSendMessage(q);
          });
        }
      } else
        document.addEventListener("DOMContentLoaded", getInitialSuggestions);
    }


    function onOpenAIKeySubmit(event) {
      event.preventDefault();
      localStorage.setItem("openai_key", userInputElem.value);
      setTimeout(() => document.location.reload(), 1000);
    }

    async function getInitialSuggestions() {
      chatActiveHistory = [{ role: "system", content: instructions }];
      chatHistoryElem.innerHTML = "";
      appendBubble("thinking", "...");
      let initialSuggestions = getNextInitialSuggestionsFromCache() || await getInitialSuggestionsFromAI();
      let message = "What do you want to explore? WHAT NEXT?" + initialSuggestions;
      await appendAssistantMessage(message);
      refreshButtonElem.style.opacity = 1;
      await storeNextInitialSuggestionsToCache();
      userInputElem.placeholder = "...or anything else (related or not)";
    }

    async function storeNextInitialSuggestionsToCache() {
      const nextInitialSuggestions = await getInitialSuggestionsFromAI();
      localStorage.setItem("nextInitialSuggestions", nextInitialSuggestions);
    }

    function getNextInitialSuggestionsFromCache() {
      var suggestions = localStorage.getItem("nextInitialSuggestions");
      return suggestions;      
    }

    async function getInitialSuggestionsFromAI(){
      const visitedInitialPrompts = JSON.parse(localStorage.getItem("visitedInitialPrompts")) || [];
      if (visitedInitialPrompts.length > 0){
        archiveButtonElem.style.opacity = 1;
        let initialPrompt = "Here are some topics I've already found interesting:\n- " + visitedInitialPrompts.reverse().join("\n- ") + "\n\n";
        initialPrompt += "Now give me a list of 7 other topics I could find interesting to explore. Be very succinct. Just output the list.";
        return await getChatCompletionFromAI([{ role: "user", content: initialPrompt }]);
      } else {
        let initialPrompt = "Give me a list of 7 interesting topics to explore. Be very succinct. Just output the list.";
        return await getChatCompletionFromAI([{ role: "user", content: initialPrompt }]);
      }
    }

    function showArchive() {
      const visitedInitialPrompts = JSON.parse(localStorage.getItem("visitedInitialPrompts")) || [];
      chatActiveHistory = [{ role: "system", content: instructions }];
      chatHistoryElem.innerHTML = "";
      appendBubble("user", "What I've explored so far:");
      visitedInitialPrompts.reverse();
      visitedInitialPrompts.forEach(async suggestion => {
        var suggestionBubble = await appendSuggestionBubbleAndGetFromAI(suggestion);
        let pressTimer;
        suggestionBubble.addEventListener("touchstart", () => 
          pressTimer = setTimeout(()  => {
            suggestionBubble.remove();
            const visitedInitialPrompts = JSON.parse(localStorage.getItem("visitedInitialPrompts")) || [];
            localStorage.setItem("visitedInitialPrompts", JSON.stringify(visitedInitialPrompts.filter(item => item !== suggestion)));
          }, 1500));
        suggestionBubble.addEventListener("touchend", () => clearTimeout(pressTimer));
      });
      archiveButtonElem.style.opacity = 0;
      refreshButtonElem.style.opacity = 1;
    }

    function onSubmit(event) {
      event.preventDefault();
      if (isScrollToTopState())
        scrollToTop();
      else {
        appendSuggestionBubbleAndGetFromAI(userInputElem.value, true);
        userSendMessage(userInputElem.value);
        clearUserInput();
      }
    }

    function updateInputButtonText() {
      sendButtonElem.innerText = userInputElem.value === "" && document.activeElement != userInputElem ? "⤒" : "→";
      updateInputButtonDisabled();
    }

    function clearUserInput() {
      userInputElem.value = "";
      updateInputButtonText();
    }

    function storeTopMessageInArchive(message) {
      const visitedInitialPrompts = JSON.parse(localStorage.getItem("visitedInitialPrompts")) || [];
      if (!visitedInitialPrompts.includes(message))
        visitedInitialPrompts.push(message);
      localStorage.setItem("visitedInitialPrompts", JSON.stringify(visitedInitialPrompts));
      archiveButtonElem.style.opacity = 1;
    }

    async function userSendMessage(userMessage) {
      if (document.querySelectorAll(".user").length == 0)
        storeTopMessageInArchive(userMessage);
      chatActiveHistory.push({ role: "user", content: userMessage });
      appendBubble("user", userMessage);
      appendBubble("thinking", "...").scrollIntoView({ behavior: "smooth" });
      await fetchAndDisplayAIResponse();
    }

    async function fetchAndDisplayAIResponse() {
      try {
        const record = await getChatCompletionFromCache(chatActiveHistory);
        await appendAssistantMessage(record.message);
        record.visited = true;
        await setDataInDB(record);
      } catch (error) {
        appendAssistantMessage(error.message);
      }
    }

    async function appendAssistantMessage(message) {
      chatActiveHistory.push({ role: "assistant", content: message });
      chatHistoryElem.lastElementChild?.remove(); // remove the thinking message, if there is one
      const [messagePart, suggestions] = parseMessageAndSuggestions(message);
      appendBubble("assistant", messagePart).scrollIntoView({ behavior: "smooth" });
      suggestions.forEach(async suggestion => await appendSuggestionBubbleAndGetFromAI(suggestion));
    }

    function parseMessageAndSuggestions(message) {
      let [messagePart, rawSuggestions] = message.trim("\"").split("WHAT NEXT?");
      if (!rawSuggestions) {
        // sometimes the assistant doesn't write "WHAT NEXT?" and just gives the suggestions
        const lastOne = Math.max(message.lastIndexOf("1."), message.lastIndexOf("1)"));
        if (lastOne > 0)
          [messagePart, rawSuggestions] = [message.slice(0, lastOne), message.slice(lastOne)];
      }
      // Regular expression to match the leading numbers and period or a parenthesis 1. 2. 3. or 1) 2) 3) etc., and also leading hyphens (-).
      const numberAndDot = /^-?(\d+[\.\)])?\s+/;
      const leadingAndEndingQuotes = /^['"]|['"]$/g;
      const suggestionsPart = !rawSuggestions ? [] : rawSuggestions.split("\n").map(s => s.replace(numberAndDot, "").replace(leadingAndEndingQuotes, '').trim()).filter(s => s != "");
      return [messagePart.trim(), suggestionsPart];
    }

    function appendBubble(role, message) {
      const newMessageElement = document.createElement("div");
      newMessageElement.classList.add(role);
      newMessageElement.innerHTML = marked.parse(message, { "breaks": true }).trim();
      chatHistoryElem.appendChild(newMessageElement);
      return newMessageElement;
    }

    async function appendSuggestionBubbleAndGetFromAI(message, hidden = false) {
      const suggestionBubble = appendBubble("suggestion", message);
      if (hidden)
        suggestionBubble.classList.add("hidden");
      suggestionBubble.addEventListener("click", () => onSuggestionClick(suggestionBubble, message));
      let possibleNewChatHistory = [...chatActiveHistory];
      possibleNewChatHistory.push({ role: "user", content: message });
      const record = await storeChatCompletionFromAIToCache(possibleNewChatHistory);
      if (record.visited)
        suggestionBubble.classList.add("visited");
      return suggestionBubble;
    }

    async function onSuggestionClick(suggestionBubble, message) {
      showSiblingSuggestionsAndRemoveAllMessagesToBottom(suggestionBubble);
      suggestionBubble.classList.add("hidden");
      await userSendMessage(message);
    }

    function showSiblingSuggestionsAndRemoveAllMessagesToBottom(suggestionBubble) {
      function showSiblingSuggestions(startBubble, direction) {
        let sibling = startBubble[direction];
        while (sibling && sibling.classList.contains("suggestion")) {
          if (sibling.classList.contains("hidden")) {
            sibling.classList.remove("hidden");
            sibling.classList.add("visited");
          }
          sibling = sibling[direction];
        }
        return sibling;
      }
      showSiblingSuggestions(suggestionBubble, "previousSibling");
      let nextSiblingNonSuggestion = showSiblingSuggestions(suggestionBubble, "nextSibling");
      removeAllMessagesFromThisToBottom(nextSiblingNonSuggestion);
    }

    function removeAllMessagesFromThisToBottom(nextSibling) {
      let userMessagegDeleted = 0;
      while (nextSibling) {
        let storeNextSibling = nextSibling.nextSibling;
        if (nextSibling.classList.contains("user"))
          userMessagegDeleted++;
        nextSibling.remove();
        nextSibling = storeNextSibling;
      }
      if (userMessagegDeleted)
        chatActiveHistory = chatActiveHistory.toSpliced(- userMessagegDeleted * 2);
    }

    const getAllPreviousUserMessages = (previousMessages) => previousMessages.filter(m => m.role === "user").map(m => m.content).join(historySeparator);

    async function storeChatCompletionFromAIToCache(previousMessages) {
      const allPreviousUserMessages = getAllPreviousUserMessages(previousMessages);
      let record = await getDataFromDB(allPreviousUserMessages);
      if (record)
        return record;
      message = await getChatCompletionFromAI(previousMessages);
      record = { key: allPreviousUserMessages, message: message, visited: false };
      await setDataInDB(record);
      return record;
    }

    async function getChatCompletionFromCache(previousMessages) {
      const allPreviousUserMessages = getAllPreviousUserMessages(previousMessages);
      let record;
      do {
        record = await getDataFromDB(allPreviousUserMessages);
      } while (!record);
      return record;
    }

    async function getChatCompletionFromAI(previousMessages, temperature = 1) {
      // send just the instructions + the last 6 messages (to save tokens)
      const previousMessagesTrimmed = (previousMessages.length > 7) ? [previousMessages[0], ...previousMessages.slice(-6)] : [...previousMessages];
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": "Bearer " + openai_key },
        body: JSON.stringify({ model: "gpt-3.5-turbo", messages: previousMessagesTrimmed, temperature:temperature })
      });
      if (response.status === 401) {
        localStorage.removeItem("openai_key");
        document.location.reload();
      }
      if (!response.ok) return "Error: " + response.text;
      const { choices } = await response.json();
      return choices[0].message.content;
    }

    async function getIndexDBStore() {
      const tableName = "messagesV3";
      const db = await new Promise((resolve, reject) => {
        const request = indexedDB.open("ChatDB", 7);
        request.onupgradeneeded = e => {
          if (!e.target.result.objectStoreNames.contains(tableName)) {
            e.target.result.createObjectStore(tableName, { keyPath: "key" });
          }
        };
        request.onerror = e => reject("IndexedDB error: " + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
      const tx = db.transaction(tableName, "readwrite");
      const store = tx.objectStore(tableName);
      return store;
    }

    async function putOrGetInIndexDB(keyOrObject) {
      const store = await getIndexDBStore();
      return new Promise((resolve, reject) => {
        const request = typeof keyOrObject === "object" ? store.put(keyOrObject) : store.get(keyOrObject);
        request.onerror = e => reject("IndexedDB error: " + e.target.errorCode);
        request.onsuccess = e => resolve(e.target.result);
      });
    }

  </script>
</body>

</html>