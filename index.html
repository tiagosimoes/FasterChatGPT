<!DOCTYPE html>
<html>

<head>
  <title>OpenAI Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <meta name="apple-mobile-web-app-status-bar-style" content="rgb(57, 161, 250)">
  <link rel="manifest" href="/manifest.json">
</head>

<body>
  <div
    style="background-color: rgb(57, 161, 250); color:#ffffffee; width: 100%;top:0;padding:20px;z-index: 1; text-align: center;">
    Never Stop Learning</div>
  <div id="chatHistory" style="margin: auto;margin-bottom: 90px;"><div class="thinking"><p>...</p></div></div>
  <form id="chatForm"
    style="position: fixed;display: block;width: 100%;bottom: 0;padding: 10px;background-color: #fff;">
    <input id="userInput" type="text" placeholder="...or anything else (related or not)"
      style="width: calc(100% - 50px);margin: auto;box-sizing: border-box;padding: 10px;border: 1px solid #ccc;border-radius: 10px;"></input>
    <button type="submit" id="sendButton"
      style="width:40px;height: 40px;border-radius: 10px;padding:0;background-color: rgb(57, 161, 250);color:#ffffffee;">&#10140;</button>
  </form>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      font-size: large;
    }

    * {
      box-sizing: border-box;
    }

    p {
      margin-block-end: 0;
      margin-block-start: 0;
    }

    .user,
    .assistant,
    .thinking,
    .suggestion {
      border-radius: 10px;
      padding: 10px;
      margin: 10px auto;
      width: fit-content;
      max-width: 90%;
      max-width: 80%;
      animation: grow .2s forwards;
    }

    .user {
      background-color: rgb(57, 161, 250);
      color: #ffffffee;
      margin-left: 20px;
      transform-origin: top left;
    }

    .assistant,
    .thinking,
    .suggestion {
      background-color: rgb(228, 227, 230);
      color: #000000dd;
      margin-right: 20px;
      transform-origin: top right;
    }

    .suggestion {
      cursor: pointer;
      color: rgb(1, 66, 128);
      font-size: 16px;
      opacity: .7;
      transition: all .2s;
    }

    .suggestion.hidden {
      background-color: rgb(57, 161, 250, 50%);
      margin-top: 0;
      margin-bottom: 0;
      font-size: 0;
      padding: 0;
    }

    .thinking>p {
      animation: grow .5s infinite alternate;
    }

    @keyframes grow {
      from {
        transform: scale3d(0, 0, 1);
        opacity: 0;
      }

      to {
        transform: scale3d(1, 1, 1);
      }
    }
  </style>

  <script>
    var openai_key =  location.hash.slice(1) || localStorage.getItem('openai_key');
    if (!openai_key) 
      alert("Please provide an API key by appending #OPENAI-API-KEY to the URL and refresh the page.");

    const initialPrompt = "Give me a list of 7 random different and interesting topics I could explore. Be very succinct. Just output the list.";
    chatComplete([{ "role": "user", "content": initialPrompt }], temperature = 1.2)
      .then(message => {
        message = "What do you want to explore? WHAT NEXT?" + message;
        if (document.readyState === 'loading')
          document.addEventListener("DOMContentLoaded", () => appendMessage("assistant", message));
        else
          appendMessage("assistant", message);
      });

    const instructions = `
You are a direct, clear and fast GPT designed to offer very concise (non creative) answers with one or two sentences and then 3 suggestions for the follow up conversation. 
You should always make educated guesses. 
At the end of any response, write "WHAT NEXT?" and present 3 likely follow-up user prompts.
Clarifications, if necessary, are included in the 3 suggestions.
`;
    let chatHistory = [{ "role": "system", "content": instructions }];

    function appendMessage(role, message) {
      const chatHistoryElement = document.getElementById('chatHistory');
      chatHistory.push({ role, content: message });
      if (role === "assistant") {
        chatHistoryElement.lastChild?.remove(); // remove the thinking message
        [message, rawSuggestions] = message.split("WHAT NEXT?");
        // Regular expression to match the leading numbers and period
        const numberAndDot = /^\d+\.\s+/;
        const suggestions = rawSuggestions.split("\n").map(s => s.replace(numberAndDot, '').trim()).filter(s => s != "");
        message = message.trim();
        addBubble(role, message);
        suggestions.forEach(suggestion => {
          addBubble("suggestion", suggestion);
          possibleNewChatHistory = [...chatHistory].concat([{ "role": "user", "content": suggestion }]);
          chatComplete(possibleNewChatHistory);
        });
      } else { // user
        addBubble(role, message);
        addBubble("thinking", "...");
      }

      function addBubble(role, message) {
        const newMessageElement = document.createElement('div');
        newMessageElement.classList.add(role);
        newMessageElement.innerHTML = marked.parse(message, { "breaks": true }).trim();
        if (role === "suggestion")
          newMessageElement.addEventListener('click', () => {
            sendMessage(message);
            newMessageElement.classList.add("hidden");
            setTimeout(() => newMessageElement.remove(), 200);
          });
        chatHistoryElement.appendChild(newMessageElement);
        if (role !== "suggestion")
          newMessageElement.scrollIntoView({ behavior: 'smooth' , block: 'start'});
      }
    }

    async function sendMessage(userInput) {
      appendMessage("user", userInput);
      try {
        newMessage = await chatComplete(chatHistory);
        appendMessage("assistant", newMessage);
      } catch (error) {
        appendMessage("assistant", error.message);
      }
    }
    document.getElementById('chatForm').addEventListener('submit', function (event) {
      event.preventDefault(); // Prevent the default form submission
      const userInput = document.getElementById('userInput').value;
      sendMessage(userInput); // Call the sendMessage function
      document.getElementById('userInput').value = '';
    });

    async function chatComplete(previousMessages, temperature = 1) {
      const onlyUserMessages = previousMessages.filter(message => message.role === "user").map(message => message.content).join("\n");
      let message = await getDataFromDB(onlyUserMessages);
      if (message)
        return message;
      if (previousMessages.length > 5) {
        // send just the instructions + the last 4 messages (to save tokens)
        previousMessages = previousMessages.toSpliced(1, previousMessages.length - 5);
      }
      localStorage.setItem('openai_key', openai_key);
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ` + openai_key },
        body: JSON.stringify({ model: 'gpt-3.5-turbo', messages: previousMessages, temperature: temperature })
      });
      if (!response.ok) throw new Error("API communication error");
      const { choices } = await response.json();
      message = choices[0].message.content;
      if (onlyUserMessages !== initialPrompt)
        setDataInDB(onlyUserMessages, message);
      return message;
    }

    async function openDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("ChatDB", 1);
        request.onupgradeneeded = e => e.target.result.createObjectStore("chats", { keyPath: "id" });
        request.onsuccess = e => {
          const db = e.target.result;
          const tx = db.transaction("chats", "readwrite");
          const store = tx.objectStore("chats");
          resolve(store);
        };
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
      });
    }

    async function getDataFromDB(key) {
      const store = await openDB();
      return new Promise((resolve, reject) => {
        const request = store.get(key);
        request.onsuccess = e => resolve(e.target.result ? e.target.result.data : null);
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
      });
    }

    async function setDataInDB(key, data) {
      const store = await openDB();
      return new Promise((resolve, reject) => {
        const request = store.put({ id: key, data: data });
        request.onsuccess = e => resolve(e.target.result);
        request.onerror = e => reject('IndexedDB error: ' + e.target.errorCode);
      });
    }
  </script>
</body>

</html>